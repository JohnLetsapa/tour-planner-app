"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convertToRGBTriplet;

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _setPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/setPrototypeOf"));

var _js = require("@adeira/js");

var _cssColorNames = _interopRequireDefault(require("./cssColorNames"));

var _hex3ToHex = _interopRequireDefault(require("./hex3ToHex6"));

var _isColor = _interopRequireDefault(require("./isColor"));

var _isRGBA = require("./utils/isRGBA");

function _wrapRegExp() { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, undefined, groups); }; var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = new RegExp(re, flags); _groups.set(_this, groups || _groups.get(re)); return (0, _setPrototypeOf2.default)(_this, BabelRegExp.prototype); } (0, _inherits2.default)(BabelRegExp, RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === "string") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } else if (typeof substitution === "function") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = arguments; if (_typeof(args[args.length - 1]) !== "object") { args = [].slice.call(args); args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp.apply(this, arguments); }

var HEX_REGEXP_SHORT = /*#__PURE__*/_wrapRegExp(/^#([0-9a-f])([0-9a-f])([0-9a-f])$/i, {
  R: 1,
  G: 2,
  B: 3
});

var HEX_REGEXP_LONG = /*#__PURE__*/_wrapRegExp(/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i, {
  R: 1,
  G: 2,
  B: 3
});
/**
 * Tries to convert the input value into RGB triplet which is commonly used throughout this library
 * for further calculations (brightness, accessibility, â€¦). The input value can be anything that is
 * valid in CSS/HTML.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
 *
 * It throws an error when the conversion is not implemented yet.
 *
 * TODO: How to deal with alpha channel (not supported in the triplet). Should we introduce custom
 *  object to keep all the extracted values?
 */


function convertToRGBTriplet(value) {
  if ((0, _isColor.default)(value)) {
    var rgbaColorMatch = value.match(_isRGBA.RGBA_PATTERN_MATCH);

    if (_cssColorNames.default.has(value)) {
      var hexColor = _cssColorNames.default.get(value); // $FlowIssue[incompatible-call]: `hexColor` should not be undefined after calling `has` above


      return convertHexToRGBTriplet(hexColor);
    } else if (HEX_REGEXP_LONG.test(value)) {
      return convertHexToRGBTriplet(value);
    } else if (HEX_REGEXP_SHORT.test(value)) {
      return convertHexToRGBTriplet((0, _hex3ToHex.default)(value));
    } else if (rgbaColorMatch) {
      var _rgbaColorMatch$group, _rgbaColorMatch$group2, _rgbaColorMatch$group3;

      return convertRGBToTriplet((_rgbaColorMatch$group = rgbaColorMatch.groups) === null || _rgbaColorMatch$group === void 0 ? void 0 : _rgbaColorMatch$group.R, (_rgbaColorMatch$group2 = rgbaColorMatch.groups) === null || _rgbaColorMatch$group2 === void 0 ? void 0 : _rgbaColorMatch$group2.G, (_rgbaColorMatch$group3 = rgbaColorMatch.groups) === null || _rgbaColorMatch$group3 === void 0 ? void 0 : _rgbaColorMatch$group3.B);
    }

    throw new Error((0, _js.sprintf)('Conversion of color "%s" is currently not supported.', value));
  } else {
    throw new Error((0, _js.sprintf)('Value "%s" is not a color!', value));
  }
}

function convertHexToRGBTriplet(hexColor) {
  var _hexColorMatch$groups, _hexColorMatch$groups2, _hexColorMatch$groups3;

  // TODO: we currently ignore alpha channels of the #RGB colors (#RGBA)
  var hexColorMatch = hexColor.match(HEX_REGEXP_LONG);
  return [parseInt(hexColorMatch === null || hexColorMatch === void 0 ? void 0 : (_hexColorMatch$groups = hexColorMatch.groups) === null || _hexColorMatch$groups === void 0 ? void 0 : _hexColorMatch$groups.R, 16), parseInt(hexColorMatch === null || hexColorMatch === void 0 ? void 0 : (_hexColorMatch$groups2 = hexColorMatch.groups) === null || _hexColorMatch$groups2 === void 0 ? void 0 : _hexColorMatch$groups2.G, 16), parseInt(hexColorMatch === null || hexColorMatch === void 0 ? void 0 : (_hexColorMatch$groups3 = hexColorMatch.groups) === null || _hexColorMatch$groups3 === void 0 ? void 0 : _hexColorMatch$groups3.B, 16)];
}

function convertRGBToTriplet(r, g, b) {
  return [Number(r !== null && r !== void 0 && r.endsWith('%') ? convertPercentageToNumber(r) : r), Number(g !== null && g !== void 0 && g.endsWith('%') ? convertPercentageToNumber(g) : g), Number(b !== null && b !== void 0 && b.endsWith('%') ? convertPercentageToNumber(b) : b)];
}

function convertPercentageToNumber(percentage) {
  var _percentage$match;

  var match = percentage === null || percentage === void 0 ? void 0 : (_percentage$match = percentage.match( /*#__PURE__*/_wrapRegExp(/^([0-9]+)%$/, {
    number: 1
  }))) === null || _percentage$match === void 0 ? void 0 : _percentage$match.groups;
  return Math.round(255 / 100 * Number(match === null || match === void 0 ? void 0 : match.number));
}